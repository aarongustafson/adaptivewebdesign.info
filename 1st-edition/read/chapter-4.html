<!DOCTYPE html>
<html lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8"/>
  	<title>Chapter 4: Progressive Enhancement with JavaScript - Adaptive Web Design: Crafting Rich Experiences with Progressive Enhancement</title>
	<!--[if IE]>
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta http-equiv="cleartype" content="on">
	<![endif]-->

	<link href="template.css" rel="stylesheet" type="text/css">

	<meta name="copyright" content="Copyright © 2011 Aaron Gustafson">

	<meta property="og:title" content="Adaptive Web Design: Crafting Rich Experiences with Progressive Enhancement">
	<meta property="og:url" content="http://adaptivewebdesign.info/">
	<meta name="author" content="Aaron Gustafson">
	<meta property="og:type" content="book">
	<meta property="og:site_name" content="Adaptive Web Design: Crafting Rich Experiences with Progressive Enhancement">
	<meta property="og:image" content="http://adaptivewebdesign.info/i/1st-ed/cover.png">
	<meta property="og:locale" content="en_US">
	<meta property="og:description" content="Aaron Gustafson chronicles the origins of progressive enhancement, its philosophy, its mechanisms, and reveals practical ways to apply progressive enhancement using HTML, CSS, and JavaScript.">
	<meta name="description" content="Aaron Gustafson chronicles the origins of progressive enhancement, its philosophy, its mechanisms, and reveals practical ways to apply progressive enhancement using HTML, CSS, and JavaScript.">

	<meta name="revisit-after" content="7 days">
	<meta name="ROBOTS" content="index,follow">
	<meta name="robots" content="NOODP">

	<link href="https://plus.google.com/+AaronGustafson?rel=author" rel="publisher">
	<meta property="fb:admins" content="100002880350996">
	
	<link href="favicon.png" rel="icon">
	
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="MobileOptimized" content="width">
	<meta name="HandheldFriendly" content="true">
	
	<link rel="manifest" href="manifest.json">
	<meta name="theme-color" content="#0c5863">
</head>

<body>
	<div id="page-topper" class="page">
		<hgroup>
			<h1>ADAPTIVE WEB DESIGN</h1>
			<h2>Crafting Rich Experiences with Progressive Enhancement</h2>
		</hgroup>
		<p class="byline">by Aaron Gustafson</p>
  	</div>
  	
	<div id="chapter-4" class="page">
		<header>
			<h1 id="chapter-title"><strong>CHAPTER 4: </strong>PROGRESSIVE ENHANCEMENT WITH&#160;JAVASCRIPT</h1>
		</header>

	    <blockquote class="ch-quote">
	    	<p>“I don’t want to use a tool unless I’m going to use it really well. Doing any of these things halfway is worse than not at all. People don’t want a mediocre&#160;interaction.”</p>
	    	<p class="author">— Seth Godin</p>
	    </blockquote>

	    <p>On February 7th, 2011, shortly after Gawker Media launched a unified redesign of their various blogs (Lifehacker, Gizmodo, etc.), users visiting any of those sites were greeted by a blank stare (see Figure 4.1). The new platform relied entirely on JavaScript to load content into the page and an error in that JavaScript code made any page request come up empty-handed.<a class="footnote-link" href="#footnote-222-1" id="footnote-222-1-backlink">[1]</a> That single error caused a lengthy “site outage” (I use that term liberally because the servers were still working) for every Gawker property and lost them countless page views and ad impressions. And it could have been avoided, had they designed their new platform using progressive enhancement.</p>
	
		<figure id="figure-4-1">
			<img alt="" src="images/Ch4-1.jpg" />
			<figcaption>
				<p><strong>Figure 4.1:</strong> Lifehacker. Empty.</p>
			</figcaption>
		</figure>

		<p>Nothing really makes a web page sing quite like JavaScript. With it, you can create rich interactions, build dynamic interfaces, and so on. Web developers realized this early on. They jumped at the opportunity to wield this powerful tool to build more engaging web pages, validate form data, and more. For today’s JavaScript developers, it’s easy to make something amazing and stick to the progressive enhancement philosophy, but it wasn’t always that way.</p>

		<p>Back in the mid-to-late ’90s, coding JavaScript was like practicing a dark art. For every bit of spaghetti code we had in our HTML, it was usually ten times worse in JavaScript because the two dominant browsers at the time, Netscape and Internet Explorer, each had their own implementation of the language<a class="footnote-link" href="#footnote-222-2" id="footnote-222-2-backlink">[2]</a> and they differed just enough to make the really interesting stuff incredibly gnarly to write. For example, finding the same element (e.g., <code>#location</code>) in the document (technically the Document Object Model or DOM) required two incredibly different syntaxes:</p>

		<pre>document.layers['location']; <b class="comment">// Netscape</b>
document.all['location']; <b class="comment">// IE</b></pre>

		<p>This unfortunate reality required us to essentially write every script twice, or at least fill it with “forks” (alternate paths for a script to take, based on the browser) that came back to “fork” us in the end.</p>

		<p>As we discussed in <a href="#chapter-2">Chapter 2</a>, the late ’90s was a period of great turmoil on the web: the browser wars. With each new release, Netscape and Microsoft offered up new goodies for developers to use, hoping to capture a greater share of the browser market. This one-upmanship created a lot of problems for developers; with the two competing implementations of JavaScript, we spent so much time trying to even out the discrepancies that we didn’t pay attention to how the language functioned or learn the best way to integrate it with HTML and CSS.</p>

		<p>When the European Computer Manufacturers Association (ECMA) International standardized JavaScript<a class="footnote-link" href="#footnote-222-3" id="footnote-222-3-backlink">[3]</a> and the W3C released its DOM spec, the shifting sands beneath our feet were finally replaced with a solid foundation and we were able to start figuring out better ways of doing things:</p>

		<pre><b class="comment">// Unified DOM</b>
document.getElementById('location');</pre>

		<h2 id="getting-out-of-the-way">GETTING OUT OF THE&#160;WAY</h2>

		<p>One of the first lessons we learned when the dust settled was that JavaScript was not a panacea for interaction on the web. In fact, it wasn’t even all that reliable.</p>

		<p>First off, even after the W3C standardized the DOM and the browsers generally agreed to support web standards, not everyone was reading from the same playbook; there were enough differences between implementations that it was simply impossible to make any assumptions about the availability of certain methods (such as the lynchpin DOM traversal methods <code>document.getElementById()</code>, which provides access to elements based on their <code>id</code> or <code>document.getElementsByTagName()</code> which, you guessed it, finds elements based on their name). Secondly, even if a browser did have full JavaScript support, the user (or her IT administrator) still had the final say over whether or not JavaScript was even allowed to run.<a class="footnote-link" href="#footnote-222-4" id="footnote-222-4-backlink">[4]</a></p>

		<p>Over time, we realized that JavaScript support was not a given and we began to re-factor our code, making it cleaner, more maintainable, and more flexible to deal with the availability (or absence) of JavaScript. Let’s examine the thinking during that period to better understand how to use JavaScript progressively.</p>

		<p><em>Warning: From here on out, we’ll be diving into actual JavaScript code. If you have not worked much with JavaScript before, have no fear, I’ll do my best to explain what’s happening at every step of the way so that you can follow along, even if the code reads like Sanskrit to you.</em></p>

		<h3 id="complete-reliance">100% reliance</h3>

		<p>Back in the early days of JavaScript, it was not uncommon to write (or at least see) onclick event handlers (scripts executed when someone clicked an element on the page) adorning otherwise useless links.<a class="footnote-link" href="#footnote-222-5" id="footnote-222-5-backlink">[5]</a></p>

		<pre>&lt;a href="#" onclick="newWin( 'http://easy-designs.net/' );"&gt;<b class="text">Easy! Designs</b>&lt;/a&gt;</pre>

		<p>With JavaScript enabled, this link calls a custom function named <code>newWin</code>, passing it a value of “http://easy-designs.net/.” That function, in turn, opens that URL in a new window. Without JavaScript, however, the link wouldn’t do anything because, as you’ll recall from our discussion of identifiers in <a href="#chapter-2">Chapter 2</a>, the <code>href</code> points to an empty <code>id</code>. What’s the point of a link that won’t work without JavaScript?</p>

		<p>Which brings me to my first maxim for progressive enhancement with JavaScript:</p>

		<p class="takeaway"><strong>Make sure all content is accessible and all necessary tasks can be completed without JavaScript turned on.</strong></p>

		<p>This link obviously violates that (as does the Gawker platform I mentioned earlier), but so did the vast majority of JavaScript in use on the web by the end of the ’90s. At that time, the web was lousy with sites that required JavaScript and places where it got in the way of users; in other words, where JavaScript was obtrusive. Realizing this problem, web developers began to push for “unobtrusive” JavaScript.</p>

		<p><em>Note: I’m not advocating the use of popups or using JavaScript to open new windows as they introduce a number of accessibility and usability issues. I have, however, chosen this as an example because it illustrates the evolution of our JavaScript code in a manner that’s relatively easy to follow. Rest assured, the lessons you’ll learn by following this example are universally applicable to any other JavaScript-ing you might do.</em></p>

		<h3 id="becoming-unobtrusive">Becoming unobtrusive</h3>

		<p>Unobtrusive JavaScript is a catch-all term for programming in a manner that is not reliant on JavaScript. Under this paradigm, users are given access to all page content and can accomplish every necessary task on a page using the basic building blocks of the web (HTML and the HTTP protocol). JavaScript is then layered on to enhance the page.</p>

		<p>Sound familiar? Unobtrusive JavaScript is an idea that meshes perfectly with progressive enhancement philosophy because it forces JavaScript into the role of functional enhancement, as opposed to absolute requirement.</p>

		<p>With unobtrusive JavaScript in mind, we re-factored our links to work whether JavaScript was available or not:</p>

		<pre>&lt;a href="http://easy-designs.net/" onclick="newWin( this.href ); return false;"&gt;<b class="text">Easy! Designs</b>&lt;/a&gt;</pre>

		<p>In this revision, the link actually points to a URL so it will function without JavaScript. When JavaScript is available, however, clicking the link will call <code>newWin</code>, which is passed the value of the link’s <code>href</code> attribute (the DOM value <code>this.href</code>). The other key difference between this and the previous version of the link is that the <code>onclick</code> event handler is also set to “return false,” which cancels the click event’s default action (in this case, following the link to a new page).</p>

		<p>This was a great first step to address the potential absence of JavaScript, but we soon realized there were better ways to manage scenarios like this.</p>

		<h3 id="more-maintainable">More maintainable</h3>

		<p>The next step in the evolution of this code involved using the age-old <code>rel</code> attribute (which you’ll recall from <a href="#chapter-2">Chapter 2</a>) to migrate our inline JavaScript code to an external file. This provided two benefits: 1) it gave an additional semantic meaning to the link and 2) it made maintaining websites much easier because developers could change a single JavaScript file and affect the entire site (which is the exact argument we made for external stylesheets over inline use of the <code>style</code> attribute). Here’s the new HTML:</p>

		<pre>&lt;a rel="external" href="http://easy-designs.net/"&gt;<b class="text">Easy! Designs</b>&lt;/a&gt;</pre>

		<p>From there, it’s fairly simple to apply the click event to this and any other “external” links:</p>

		<pre>var links = document.getElementsByTagName( 'a' ),
    rel, i = links.length;
while ( i-- )
{
  rel = links[i].getAttribute( 'rel' );
  if ( rel &amp;&amp; rel.match( /\bexternal\b/ ) )
  {
    links[i].onclick = function()
    {
      newWin( this.href );
      return false;
    };
  }
}</pre>

		<p>If all those “ifs” and “whiles” are Greek to you, here’s a quick summary of what the script does: it collects all of the links on the page and loops through them (in reverse order which, oddly enough, is a bit faster than going forward); and if the link has a <code>rel</code> attribute and its value contains the text “external,” the link’s <code>onclick</code> event is assigned an anonymous function that calls a function named <code>newWin</code> (passing it the value of the link’s <code>href</code> attribute just like in the previous example) before canceling the click’s default action by returning false.</p>

		<p>Finally, we’d come upon a decent solution that was just about as unobtrusive as you could get and, in 2006, Jeremy Keith gave us a lovely little name for it: Hijax, a clever combination of “hijack,” referring to the fact that the link’s normal behavior was being commandeered, and Ajax, the JavaScript-based mechanism by which web pages could interact with a server without requiring a refresh in the browser. Little did we know, Ajax, which was just growing in popularity at the time, would show us we still had a thing or two to learn when it came to JavaScript event management.</p>

		<h3 id="truly-flexible">Truly flexible</h3>

		<p>With the widespread acceptance and implementation of Ajax techniques<a class="footnote-link" href="#footnote-222-6" id="footnote-222-6-backlink">[6]</a> and other methods of modifying page content on the fly, our age-old method of assigning event handlers wasn’t holding up all that well. After all, if new content was injected into the page with a link marked <code>rel="external"</code>, it wouldn’t have our custom function assigned as an <code>onclick</code> event handler. This is because our script was likely run when the page loaded (<code>window.onload()</code>) prior to the new link being injected via Ajax.</p>

		<p>This presented a tough problem to be sure. In this scenario, it was possible that two links that should act the same would actually act in completely different ways. Can you say usability issue?</p>

		<p>To address this issue, some folks re-executed the script whenever an Ajax-based HTML injection was completed. It seemed like a good idea, but calling the same function over and over again slowed the browser down considerably because it had to traverse all of the links on the page each and every time.</p>

		<p>Then Christian Heilmann reminded us that any event triggered on a particular element actually traverses the DOM tree from the root node (<code>html</code>) to that element and back again in the event capturing and bubbling phases, respectively.<a class="footnote-link" href="#footnote-222-7" id="footnote-222-7-backlink">[7]</a> That means the “click” event on a link is actually executed on every element between the root node and the link itself… twice<a class="footnote-link" href="#footnote-222-8" id="footnote-222-8-backlink">[8]</a> (see Figure 4.2). Listening for the event on an element further up the DOM tree is not only more efficient (because you could assign a single event handler rather than hundreds), but it made it possible to trigger actions on dynamic content, thereby helping us overcome the potential usability issue where similar links behaved differently.</p>

		<figure id="figure-4-2">
			<img alt="" src="images/Ch4-2.jpg" />
			<figcaption>
				<p><strong>Figure 4.2:</strong> Event capturing and bubbling.</p>
			</figcaption>
		</figure>

		<p>This concept became known as “event delegation” because a single event handler could interpret events and send out orders based on the element that triggered that event. Here’s a concise rewrite of the previous example that uses event delegation:</p>

		<pre>document.body.onclick = function( e )
{
  <b class="comment">// even out the event models</b>
  e = ( e ) ? e : event;
  var el = e.target || e.srcElement, rel;
  <b class="comment">// external links</b>
  rel = el.getAttribute( 'rel' );
  if ( el.nodeName.toLowerCase() == 'a' &amp;&amp;
       rel &amp;&amp; rel.match( /\bexternal\b/ ) )
  {
    newWin( el.href );
    <b class="comment">// cancel the default action</b>
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  }
};</pre>

		<p>This code block assigns an event handler to the <code>onclick</code> event of the body element, establishing the listener; within the listener, it determines the target element (the one that was clicked) and then checks to make sure it’s an anchor element (<code>a</code>) that has a <code>rel</code> attribute containing the string “external”; if the element meets all of those requirements, the <code>newWin</code> function is called and the event’s default action is canceled.</p>

		<p>This example, while specific, demonstrates why we must continue to evolve our approach to JavaScript-based interactions. Improving our JavaScript comprehension provides direct benefits for progressive enhancement by helping us make our code smarter and more unobtrusive, but it also helps us in terms of maintainability and performance.</p>

		<h2 id="making-what-we-need">MAKING WHAT WE&#160;NEED</h2>

		<p>By now you’re probably getting the gist of unobtrusive JavaScript, but we’ve only been looking at the user experience from the document side of things. There are numerous ways in which JavaScript-based interactions are far superior to those without it. Client-side form validation, for instance, provides the opportunity to give users immediate feedback on potential errors without requiring that they submit the form first.</p>

		<figure id="figure-4-3">
			<img alt="" src="images/Ch4-3.jpg" />
			<figcaption>
				<p><strong>Figure 4.3:</strong> Checking username availability on Twitter.com.</p>
			</figcaption>
		</figure>

		<p>As we’ve seen, we need to be careful to make sure that every interface can work without JavaScript, but what about when JavaScript needs additional markup to achieve its goals? Well, that brings us to my second maxim for progressive enhancement with JavaScript:</p>

		<p class="takeaway"><strong>Use JavaScript to generate any additional markup it needs.</strong></p>

		<p>JavaScript is really good at generating and modifying markup on the fly. So when you need to enhance an interface with JavaScript, start with a baseline of semantic, usable markup and baseline styles. Then instruct the script to make necessary HTML and CSS changes required by the new interface once it has determined that it can run without encountering errors.</p>

		<p>For an example of this in action, let’s return to the Retreats 4 Geeks page.</p>

		<figure id="figure-4-4">
			<img alt="" src="images/Ch4-4.jpg" />
			<figcaption>
				<p><strong>Figure 4.3:</strong> The Retreats 4 Geeks web page.</p>
			</figcaption>
		</figure>

		<p>I wanted to make the best possible use of space on a mobile device. The horizontal navigation will work on a small browser, but the target areas would be too small to click easily. Of course, I could switch the site to use vertical navigation, allowing for larger links, but that would take up precious screen real estate.</p>

		<p>An alternative to these two approaches is creating a dropdown using either CSS or a <code>select</code> element. While the pure CSS dropdown option is tempting, the latter approach has an edge because it provides users with a familiar user interface. For that reason, I chose the <code>select</code> route.</p>

		<p>Based on the markup introduced back in <a href="#chapter-2">Chapter 2</a>, I’ll walk you through creating a script that converts the contents of the <code>nav</code> element into a <code>select</code> when the browser shrinks below a particular size. To keep the example short and a little easier to follow, I’ve used the jQuery JavaScript library.<a class="footnote-link" href="#footnote-222-9" id="footnote-222-9-backlink">[9]</a> Libraries are great tools as they are composed of dozens if not hundreds of functions that solve common problems (like adding and removing <code>class</code>es). Don’t worry if you can’t completely follow the code, I’ll explain what’s happening so you don’t have to decipher it on your own.</p>

		<p>We’ll begin by isolating the script in an anonymous function<a class="footnote-link" href="#footnote-222-10" id="footnote-222-10-backlink">[10]</a> that runs as soon as the DOM is available, but before assets like images, CSS files, and videos have been downloaded (a.k.a. <code>onDOMReady</code>). This makes the page more responsive than running a script when the window loads (a.k.a. <code>window.onload</code>). For the remainder of this example, all of the code will be sequestered within this function:</p>

		<pre>$(function(){
  <b class="comment">// Exciting stuff will go here</b>
});</pre>

		<p>Next, we create the variables we need for this script to work. By instantiating them all at once, we’ll reduce the number of <code>var</code> statements (which helps with minification).<a class="footnote-link" href="#footnote-222-11" id="footnote-222-11-backlink">[11]</a></p>

		<pre>var
<b class="comment">// reference the window</b>
$window = $(window),
<b class="comment">// get the navigation</b>
$old_nav = $('#top nav &gt; *'),
<b class="comment">// get the links</b>
$links = $old_nav.find('a'),
<b class="comment">// track what’s showing</b>
showing = 'old',
<b class="comment">// the browser width that triggers the change</b>
trigger = 765,
<b class="comment">// we’ll use these shortly</b>
$new_nav, $option,
<b class="comment">// we’ll need a timer too</b>
timer = null;</pre>

		<p>The comments should give you a good sense of what each variable is for.</p>

		<p>If you’re familiar with jQuery, but confused as to why we’re assigning elements to local variables rather than just referencing the jQuery-based lookup (e.g., <code>$('#top nav &gt; *')</code>) each time we need it, rest assured that there’s a method to my madness: creating a local reference reduces the performance hit of running the script because the look up only happens once instead of every time <code>$()</code> is used. Also, to make it easy to differentiate jQuery results from other variables, I’ve prefaced each associated variable name with a dollar sign ($). You’ll see these techniques used throughout this script as they are helpful habits to get into.</p>

		<p>With all of our variables in place, you <em>might</em> think we could move on to the meat of the script, but we’re not quite ready for that yet. Before we try to execute code against the page, we should make sure that the elements we need actually exist:</p>

		<pre>if ( $old_nav.length &amp;&amp; $links.length )
{
  <b class="comment">/* We know the DOM elements we need exist and can do something with them */</b>
}</pre>

		<p>Testing for dependencies is very important and is something I’ll cover more thoroughly in the next section. Now for the meat (or nutmeat if you’re a vegetarian). We’ll begin our script in earnest by generating the new <code>select</code>-based navigation, creating the <code>select</code>, and the first of several <code>option</code> elements it will contain:</p>

		<pre>$new_nav = $('&lt;select&gt;&lt;/select&gt;');
$option = $('&lt;option&gt;-- Navigation --&lt;/option&gt;')
            .appendTo($new_nav);</pre>

		<p>With new markup to work with, we can now loop through the links we collected (as <code>$links</code>) and build a new option for each by repeatedly cloning the <code>option</code> we just created:</p>

		<pre>$links.each(function(){
  var $a = $(this);
  $option.clone()
    .attr( 'value', $a.attr('href') )
    .text( $a.text() )
    .appendTo( $new_nav );
});</pre>

		<p>With the <code>options</code> created and appended to the <code>select</code> we can move on to adding the final markup touches and setting up the event handler for the <code>select</code>’s <code>onchange</code> event:</p>

		<pre>$new_nav = $new_nav
             .wrap('&lt;div id="mobile-nav"/&gt;')
             .parent()
             .delegate( 'select', 'change',
                        function(){
               window.location = $(this).val();
             });</pre>

		<p>This is a slightly simplified version of what you’ll find on the live Retreats 4 Geeks site (I’ve taken out some of the URL hash trickery), but I wanted to make sure you were able to follow it without distraction. Here’s what’s going on: the first three lines wrap our <code>select ($new_nav)</code> in a <code>div</code> and then re-assign that <code>div</code> to the variable <code>$new_nav</code> so the whole thing is viewed by JavaScript as a neat little package; the next line uses event delegation (which we discussed earlier) to observe the <code>onchange</code> event on the <code>select</code> from further up the DOM tree (from the <code>div</code>, in fact), assigning an anonymous function to that event that pushes a new location to the browser’s address bar (causing the browser to jump to the new section or load a new page, depending on the link type).</p>

		<p>Boom! Functional <code>select</code>-based navigation. Now to get it into the page when conditions are right. For that, we’ll create a new function, called <code>toggleDisplay</code>, that will observe the size of the browser window and handle swapping one navigation style for another:</p>

		<pre>function toggleDisplay()
{
  var width = $window.width();
  if ( showing == 'old' &amp;&amp;
       width &lt;= trigger )
  {
    $old_nav.replaceWith($new_nav);
    showing = 'new';
  }
  else if ( showing == 'new' &amp;&amp;
            width &gt; trigger )
  {
    $new_nav.replaceWith($old_nav);
    showing = 'old';
  }
}</pre>

		<p>Again, this is a slightly simplified version of the final script, but it highlights the important part: the navigation is only swapped in the event that the appropriate browser width threshold is met (<code>trigger</code>) <em>and</em> the other navigation style is showing (tracked using <code>showing</code>). With that function in place, we just need to run it once (to initialize everything and make sure the right navigation is showing from the get-go) and then assign it to the window’s <code>onresize</code> event:</p>

		<pre>toggleDisplay(); <b class="comment">// initialize the right view</b>
$window.resize(function(){
  if ( timer ) { clearTimeout(timer); }
  timer = setTimeout( toggleDisplay, 100 );
});</pre>

		<p>If you’re wondering why <code>toggleDisplay()</code> isn’t passed in as the actual event handler, that’s because doing so would cause the function to be executed numerous times (possibly several hundred) while a user is resizing his or her browser. To keep the number of executions to a minimum (and reduce the burden the script places on a user’s CPU), the event handler uses a timer to call <code>toggleDisplay()</code> after .1 seconds. As the function is triggered repeatedly during a resize event, it destroys the timer if it exists and then recreates it. This setup ensures <code>toggleDisplay()</code> is only called once when a user resizes his or her browser (unless he or she does so <em>very</em> slowly).</p>

		<p>And there you have it: a perfect example of progressive enhancement with JavaScript.</p>

		<figure id="figure-4-5">
			<video controls="controls" poster="images/Ch4-5.jpg">
				<source src="videos/Ch4-5.m4v"/>
				<source src="videos/Ch4-5.webm"/>
				<source src="videos/Ch4-5.ogv"/>
				<img alt="" src="images/Ch4-5.jpg" />
			</video>
			<figcaption>
				<p><strong>Figure 4.5:</strong> <code>select</code>-based navigation on an iPhone.</p>
			</figcaption>
		</figure>

		<p>As this simple example demonstrates, JavaScript is perfectly capable of generating everything it needs and getting rid of anything it doesn’t. You could even take this particular function a step farther and make it even more markup agnostic by allowing the root starting point (in our case, the child elements of <code>nav</code>) to be passed dynamically into the function. But I leave that to you to experiment with. Onward!</p>

		<h2 id="keep-it-copacetic">KEEP IT COPACETIC</h2>

		<p>As we’ve covered, many of the progressive enhancement techniques available to us in HTML and CSS are pretty straightforward and may even have been part of your repertoire prior to picking up this book. Progressive enhancement with JavaScript, on the other hand, is a bit more complicated; JavaScript cannot be fault tolerant like the others because it is a programming language.</p>

		<p>Unlike HTML and CSS, which describe content and provide design instructions to a browser, respectively, JavaScript literally executes commands to the browser. Because they actually <em>do</em> something, JavaScript programs stop running when they encounter an error. The potential causes for these errors could be anything from a typo to a missing dependency to accidentally writing an infinite loop. Regardless of the cause, if you write code that doesn’t jive well with the browser’s JavaScript interpreter, it will likely spit a big fat error right in your face (or your customer’s). And no one wants that.</p>

		<p>As we’ve seen, the implementation of progressive enhancement at each stage in the continuum isn’t a binary choice of having a particular technology or not having it. Instead, a user’s experience at each level is variable based on the capabilities of the browser. So, if a user’s browser supports RGBa natively, but not rounded corners, it’s not a big deal; the user gets what she gets.</p>

		<p>We need to approach JavaScript the same way; it shouldn’t be an all or nothing option. Not to keep returning to food metaphors time and time again, but we should offer technologies in an <em>à la carte</em> fashion by dividing up the functionality into discrete, self-contained packages. Once separated, these scripts can test for their own dependencies and judge whether or not they should run based on the browsing environment and the page they are to interact with.</p>

		<p>The <code>select</code>-based navigation script we just walked through is a good example of the first part of this concept in practice; it is completely self-contained. It does not, however, properly test for its numerous dependencies, the first of which is the availability of jQuery. To do that, we would need to wrap the whole thing in a conditional:</p>

		<pre>if ( typeof( jQuery ) != 'undefined' )
{
  <b class="comment">/* Existing code goes here */</b>
}</pre>

		<p>In this brief bit of code, we are checking for the existence of the <code>jQuery</code> object, which is created when jQuery (the library) is present, by checking to see that its type is not “undefined.” Dependency testing is a useful strategy because it helps you avoid throwing errors in the browser and it can help speed up the user’s browsing experience by not executing code unnecessarily.</p>

		<p>Here’s another simple example that may prove more familiar to you:</p>

		<pre>if ( document.getElementById )
{
  <b class="comment">/* Code using document.getElementById() goes here */</b>
}</pre>

		<p>In this case, we’re making sure the DOM traversal method <code>document.getElementById</code> exists before we execute code that uses it. You probably recall us using this strategy in the event delegation example when testing for <code>event.preventDefault</code>.</p>

		<p>Returning to the jQuery test, we can take the test a step farther and check for a specific version of jQuery. This form of testing can be useful if your script uses a method not available in earlier versions of the library. In many cases, it’s smarter to test for the existence of specific methods, but version checking can be really helpful when a new release of the library substantially changes the API for a pre-existing method:</p>

		<pre>if ( typeof( jQuery ) != 'undefined' &amp;&amp;
     parseFloat( jQuery.fn.jquery ) &gt;= 1.4 )
{
  <b class="comment">/* Existing code that requires jQuery 1.4 or higher goes here */</b>
}</pre>

		<p>Testing for dependencies is a great way to ensure you don’t execute code that could throw errors and, the earlier you test, the more memory and processing time you can save a user who won’t benefit from the script in the first place. jQuery isn’t the only dependency the script has though; as you may recall, we took its markup dependencies into account when we tested the lengths of both the <code>$old_nav</code> and <code>$links</code> collections:</p>

		<pre>if ( $old_nav.length &amp;&amp; $links.length )
{</pre>

		<p>With this test in place, the script quietly exits when it has nothing to do and it doesn’t bother creating any new elements or assigning any event handlers that are destined to go unused.</p>

		<p>Following on this example, you can likely see myriad scenarios where investigation into the browsing environment and the page setup can help a script to determine whether or not it should run. Object existence, markup dependencies, method availability, cookie availability, and Ajax support are all ripe for the plucking. It’s trivial to add code that allows a script to quietly turn itself off when any of its dependencies are not available, so there’s really no reason not to do it.</p>

		<p>If you think about it, the concept of dependency testing is quite similar to using media queries in CSS. And, speaking of CSS, we should talk about how to best manage the interaction between scripts and style.</p>

		<h2 id="working-with-style">WORKING WITH&#160;STYLE</h2>

		<p>One script dependency we haven’t discussed yet is CSS. Nine times out of ten, if you are writing JavaScript that interacts with the DOM, you’re also working with CSS in one way or another. When developing with progressive enhancement in mind, it’s important to determine the best way to apply and control styles from within JavaScript so you don’t confuse your users by creating interfaces that don’t actually work. But more on that in a moment.</p>

		<p>Over the years, our understanding of how JavaScript and CSS should interact has evolved considerably. In the early days of JavaScript, style management in a script was pretty much nonexistent; we just wrote everything inline by manipulating an element’s <code>style</code> attribute:</p>

		<pre>function highlight()
{
  var el = document.getElementById( 'message' );
  el.style.color = '#f00';
  el.style.backgroundColor = '#ffcfcf';
}</pre>

		<p>From a maintenance perspective, code written in this manner is a nightmare to work with. It means any time there’s a design change, you need to get someone who understands JavaScript involved. That’s hardly efficient and violates the separation of layers; mixing presentation and behavior makes both of them harder to work with.</p>

		<p>The next step in the evolution was extracting the changeable bits to variables, either within the script itself or passing them in as part of a configuration object (keeping a sensible default in case the configuration was skipped):</p>

		<pre>function highlight( config )
{
  var el = document.getElementById( 'message' );
  el.style.color = config.color || '#f00';
  el.style.backgroundColor = config.backgroundColor || '#ffcfcf';
}</pre>

		<pre>highlight({
  color: '#ebebeb',
  backgroundColor: 'black'
});</pre>

		<p>It still requires at least a cursory knowledge of JavaScript to update the strings, but hopefully all of the style rules would be in one place, so the maintenance should be a bit easier.</p>

		<p>Eventually, however, we realized it was much more efficient to maintain style information in an external stylesheet and trigger it by manipulating the class of an element on the page:</p>

		<pre>function highlight()
{
  document.getElementById( 'message' ).className += ' highlight';
}</pre>

		<p>Not only did this reduce the amount of code necessary to accomplish the desired effect, but it also meant fewer DOM manipulations (which increased performance tremendously) and it meant the CSS could be maintained without modifying the JavaScript that would be interacting with those styles.</p>

		<p>I’m going to forgo a discussion of the different ways you can bundle your scripts and styles together while still maintaining a decent amount of separation, in favor of spending some time on when and how to best apply styles using a script. While the former is certainly an interesting topic,<a class="footnote-link" href="#footnote-222-12" id="footnote-222-12-backlink">[12]</a> the route you choose to go has more to do with your work flow and overall project needs. When and how your scripts apply styles, however, is of critical importance and is the subject of my final maxim for progressive enhancement with JavaScript:</p>

		<p class="takeaway"><strong>Apply no style before its&#160;time.</strong></p>

		<p>As we’ve already covered, most DOM scripting requires a bit of style modification as well—whether it’s to expand and collapse an element on the page, highlight newly added content, or provide visual flourishes to a drag and drop interface. Using style in this manner is perfectly legitimate, but, more often than not, developers apply styles that correspond to a given widget before they have determined if the widget can even run.</p>

		<p>Let’s take, for example, an accordion widget. In a typical accordion interface, the content blocks are hidden and only the associated headings are visible. If the styles applied to hide the content sections were applied by default and the script was unable to run, a user would be unable to click a header to reveal the hidden content. The styles would have undermined the usefulness of the interface because they were applied too early.</p>

		<p>If, on the other hand, the script itself were to trigger the application of the initial state styles when it knew it would be able to run, there would not be any problem whatsoever. If the script didn’t run, the widget-related styles would not be applied and the content would still be visible and, thereby, usable. Implementing the style application in this way, you provide one layout for the content when the widget can’t run and another set of styles when it can, optimizing both use cases.</p>

		<p>Could it be? Why yes, I think it is. Progressive enhancement perfection.</p>

		<figure id="figure-4-6">
			<video controls="controls" poster="images/Ch4-6.jpg">
				<source src="videos/Ch4-6.m4v"/>
				<source src="videos/Ch4-6.webm"/>
				<source src="videos/Ch4-6.ogv"/>
				<img alt="" src="images/Ch4-6.jpg" />
			</video>
			<figcaption>
				<p><strong>Figure 4.6:</strong> An accordion widget showing the first section expanded and the other three sections collapsed. Clicking the title of another section will cause that section to expand and the first section to collapse.</p>
			</figcaption>
		</figure>

		<p>One of the best ways to manage triggering interface styles like this is by using an “activator” <code>class</code> on the root element of the widget. Here are some quick examples:</p>

		<figure id="table-4-1">
			<table>
				<thead>
					<tr>
					<th scope="col">STRATEGY</th>
					<th scope="col">“RESTING” <br/>CLASS</th>
					<th scope="col">“ACTIVATED” <br/>CLASS</th>
					</tr>
				</thead>
				<tbody>
				<tr>
					<td>Add a suffix of “-on” to the base <code>class</code></td>
					<td><code>.accordion</code></td>
					<td><code>.accordion-on</code></td>
				</tr>
				<tr>
					<td>Add another <code>class</code></td>
					<td><code>.auto-submit</code></td>
					<td><code>.auto-submit.active</code></td>
				</tr>
				<tr>
					<td>Change the form of the <code>class</code></td>
					<td><code>.replace-me</code></td>
					<td><code>.replaced</code></td>
				</tr>
				</tbody>
			</table>
			<figcaption>
				<p><strong>Table 4.1:</strong> Using an “activator” <code>class</code>.</p>
			</figcaption>		
		</figure>

		<p>By following this practice, you can guarantee that no styles will be applied before they are needed.</p>

		<p>Another issue with style application by JavaScript is the potential for collisions. Just as it is important to isolate your scripts from one another to avoid collisions in variable, function, or method naming, it is recommended that you isolate your script-related styles from others as well. After all, you may not be able to control what other <code>class</code> names may be in use on a given page (especially if you’re releasing a script for other people to use) and if you don’t carefully sequester your styles, they can unintentionally “bleed” onto the rest of the page (i.e., they might be applied to elements you didn’t intend them to apply to).</p>

		<p>To corral your styles, it’s best to start every selector with an identifiable marker unlikely to be in conflict with another <code>class</code> or <code>id</code> on the page. I like to begin with the name of the JavaScript object. So, for example, if I built an accordion widget named (cleverly) <code>AccordionWidget</code>, I might classify the activated root element as “AccordionWidget-on” and then tree each of my styles from there:</p>

		<pre>.AccordionWidget-on .heading {
  <b class="comment">/* Heading styles here */</b>
}

.AccordionWidget-on .content-block {
  <b class="comment">/* Content block styles here */</b>
}

.AccordionWidget-on .content-block.collapsed {
  <b class="comment">/* Collapsed content block styles here */</b>
}</pre>

		<p>Obviously, there is an outside chance that style rules intended for content other than your widget could end up bleeding into the widget as well because of issues regarding specificity or the cascade. If you anticipate those potential issues, however, you can take the appropriate action by increasing the specificity of your selectors or by explicitly setting each and every property you want to control within your widget.</p>

		<h2 id="planning-and-restraint">PLANNING AND RESTRAINT</h2>

		<p>Make no mistake, progressive enhancement with JavaScript requires considerably more effort than it does with CSS or HTML. With a bit of thoughtful reflection and consideration of the numerous factors that affect the web experience, however, it quickly becomes second nature. And, when in doubt, you can always come back to the three maxims:</p>

		<ol>
		  <li>Make sure all content is accessible and all necessary tasks can be completed without JavaScript turned on.</li>
		  <li>Use JavaScript to generate any additional markup it needs.</li>
		  <li>Apply no style before its time.</li>
		</ol>

		<p>Armed with a solid understanding of how to best wield the power of JavaScript, you’re sure to make smart decisions and build even more usable sites.</p>

		<footer>
			<ol id="footnotes">
				<li><a class="backlink" href="#footnote-222-1-backlink" id="footnote-222-1">[1]</a> A brief mention of the outage was <a href="http://blogs.wsj.com/digits/2011/02/07/gawker-outage-causing-twitter-stir/">in the <cite>Wall Street Journal</cite></a>. <a href="http://adactio.com/journal/4346/">Jeremy Keith</a> and <a href="http://isolani.co.uk/blog/javascript/BreakingTheWebWithHashBangs">Mike Davies</a> provided worthwhile commentary on the JavaScript reliance of Gawker’s platform. <a href="http://easy-reader.net/archives/2011/02/09/you-cant-rely-on-javascript/">I also weighed in</a>.</li>
				<li><a class="backlink" href="#footnote-222-2-backlink" id="footnote-222-2">[2]</a> The JavaScript language itself, designed by Brendan Eich, debuted as a feature of Netscape 2 in late 1995. Microsoft developed its own dialect of JavaScript (named “JScript,” for trademark reasons) and released it in mid 1996 as part of Internet Explorer 3 (which was, coincidentally, also the first browser to offer CSS support).</li>
				<li><a class="backlink" href="#footnote-222-3-backlink" id="footnote-222-3">[3]</a> Netscape submitted JavaScript to ECMA International for consideration as a standard in 1996. The standardized version of Javascript became known as “ECMAScript,” but we generally use JavaScript unless referring to a spec.</li>
				<li><a class="backlink" href="#footnote-222-4-backlink" id="footnote-222-4">[4]</a> For IT administrators, however, the choice to disable Javascript was fundamentally a security one, but for a long time users with accessibility concerns were also encouraged to disable JavaScript. Some users also disabled JavaScript to remove annoying ads and popups. JavaScript is most easily disabled in the browser preferences, but can also be blocked by firewalls or disabled at the application level by IT administrators.</li>
				<li><a class="backlink" href="#footnote-222-5-backlink" id="footnote-222-5">[5]</a> Variations of this old school technique included the <code>javascript</code> pseudo-protocol (e.g., <code>&lt;a href=”javascript:myFunction();”&gt;</code>) and, my personal favorite, the combined use of the <code>javascript</code> pseudo-protocol and an inline event handler (e.g., <code>&lt;a href=”javascript:void(null)” onclick=”myFunction();”&gt;</code>).</li>
				<li><a class="backlink" href="#footnote-222-6-backlink" id="footnote-222-6">[6]</a> <code>XMLHttpRequest</code> is the technology that we use to make requests to the server to send and receive information without requiring the browser to refresh or reload the page. It was invented at Microsoft for Outlook Web Access and debuted in IE5, but it has been adopted by every other browser and is currently being standardized at the W3C. <code>XMLHttpRequest</code> is the backbone of Ajax (Asynchronous JavaScript and XML), but despite its namesake, it can communicate by means other than XML. The “A” in Ajax stands for “asynchronous” because this means of communication doesn’t require the user to wait for the response; she can continue interacting with the page while the script loads more information from the server.</li>
				<li><a class="backlink" href="#footnote-222-7-backlink" id="footnote-222-7">[7]</a> <a class="url" href="http://icant.co.uk/sandbox/eventdelegation/">icant.co.uk/sandbox/eventdelegation/</a></li>
				<li><a class="backlink" href="#footnote-222-8-backlink" id="footnote-222-8">[8]</a> Ok, not technically twice in every browser. The Microsoft event model, the one implemented in all versions of IE prior to 9, only supports the bubbling phase of an event. The standard W3C event model supports both event capturing and event bubbling.</li>
				<li><a class="backlink" href="#footnote-222-9-backlink" id="footnote-222-9">[9]</a> <a class="url" href="http://jQuery.com">jQuery.com</a></li>
				<li><a class="backlink" href="#footnote-222-10-backlink" id="footnote-222-10">[10]</a> Anonymous functions are functions which have not been given a name.</li>
				<li><a class="backlink" href="#footnote-222-11-backlink" id="footnote-222-11">[11]</a> <a class="url" href="http://www.alistapart.com/articles/javascript-minification-part-II/">alistapart.com/articles/javascript-minification-part-II/</a></li>
				<li><a class="backlink" href="#footnote-222-12-backlink" id="footnote-222-12">[12]</a> For an overview of that topic, you can read my article “<a href="http://scrollmagazine.com/number-1/keeping-the-hot-side-hot">Keeping the hot side hot and the cold side cold</a>” in <cite>Scroll Magazine</cite>.</li>
			</ol>
		</footer>
	</div>
	
	<nav class="navigation">
		<h1>TABLE OF CONTENTS</h1>
		<ol>
		<li><a href="index.html">Front Matter</a></li>
		<li><a href="foreword.html">Foreword</a></li>
		<li><a href="chapter-1.html">Chapter 1: Think of the User, Not the Browser</a></li>
		<li><a href="chapter-2.html">Chapter 2: Progressive Enhancement with Markup</a></li>
		<li><a href="chapter-3.html">Chapter 3: Progressive Enhancement with CSS</a></li>
		<li><a href="chapter-4.html"><mark>Chapter 4: Progressive Enhancement with JavaScript</mark></a></li>
		<li><a href="chapter-5.html">Chapter 5: Progressive Enhancement for Accessibility</a></li>
		<li><a href="chapter-6.html">Chapter 6: Take It Away</a></li>
		<li><a href="back.html">Back Matter</a></li>
		</ol>
	</nav>
	
	<aside class="signup">
		<h1>Like what you’re reading?</h1>
		<p>You should check out <a href="/2nd-edition/">the 2nd Edition, available now from New Riders</a>.</p> 		<hr> 		<p>For more Adaptive Web Design news, you can also join the mailing list:</p>
		<!-- Begin MailChimp Signup Form -->
		<p class="form-control form-control--email">
			<form action="//easy-reader.us1.list-manage.com/subscribe/post?u=ef3de4ba708a36120583e2267&amp;id=f791ea5ce6"
				  method="post" target="_blank">
				<label class="form-control__label" for="email">Email Address</label>
				<input class="form-control__input" type="email" name="EMAIL" id="email" required aria-required="true" aria-describedby="email-note">
				<input class="form-button form-button--submit" type="submit" value="Subscribe" name="subscribe">
				<em class="form-control__note" id="email-note">I will only use your email address to notify you about <cite>Adaptive Web Design</cite> and will never share or sell it.</em>
			
    			<!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
		    	<div style="position: absolute; left: -5000px;">
					<label for="b_ef3de4ba708a36120583e2267_f791ea5ce6">Label</label><input id="b_ef3de4ba708a36120583e2267_f791ea5ce6" name="b_ef3de4ba708a36120583e2267_f791ea5ce6" tabindex="-1" value="">
				</div>
				
			</form>
		</p>
	</aside>
	
	<footer class="contentinfo">
		<p>Copyright © 2011 Aaron Gustafson. All rights reserved. ISBN: 978-0-9835895-1-8</p>
	</footer>
	
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-58149754-1', 'auto');
	  ga('send', 'pageview');

	</script>

	<script>
    	// Offline access
    	if ('serviceWorker' in navigator) {
        	navigator.serviceWorker.register('/1st-edition/read/sw.js');
    	}
	</script>
</body>
</html>
