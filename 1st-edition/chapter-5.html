<!DOCTYPE html>
<html lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8"/>
  	<title>Chapter 5: Progressive Enhancement for Accessibility - Adaptive Web Design: Crafting Rich Experiences with Progressive Enhancement</title>
	<!--[if IE]>
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta http-equiv="cleartype" content="on">
	<![endif]-->

	<link href="template.css" rel="stylesheet" type="text/css">

	<meta name="copyright" content="Copyright © 2011 Aaron Gustafson">

	<meta property="og:title" content="Adaptive Web Design: Crafting Rich Experiences with Progressive Enhancement">
	<meta property="og:url" content="http://adaptivewebdesign.info/">
	<meta name="author" content="Aaron Gustafson">
	<meta property="og:type" content="book">
	<meta property="og:site_name" content="Adaptive Web Design: Crafting Rich Experiences with Progressive Enhancement">
	<meta property="og:image" content="http://adaptivewebdesign.info/i/1st-ed/cover.png">
	<meta property="og:locale" content="en_US">
	<meta property="og:description" content="Aaron Gustafson chronicles the origins of progressive enhancement, its philosophy, its mechanisms, and reveals practical ways to apply progressive enhancement using HTML, CSS, and JavaScript.">
	<meta name="description" content="Aaron Gustafson chronicles the origins of progressive enhancement, its philosophy, its mechanisms, and reveals practical ways to apply progressive enhancement using HTML, CSS, and JavaScript.">

	<meta name="revisit-after" content="7 days">
	<meta name="ROBOTS" content="index,follow">
	<meta name="robots" content="NOODP">

	<link href="https://plus.google.com/+AaronGustafson?rel=author" rel="publisher">
	<meta property="fb:admins" content="100002880350996">
	
	<link href="favicon.png" rel="icon">
	
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="MobileOptimized" content="width">
	<meta name="HandheldFriendly" content="true">
</head>

<body>
	<div id="page-topper" class="page">
		<hgroup>
			<h1>ADAPTIVE WEB DESIGN</h1>
			<h2>Crafting Rich Experiences with Progressive Enhancement</h2>
		</hgroup>
		<p class="byline">by Aaron Gustafson</p>
  	</div>
  	
	<div id="chapter-5" class="page">
		<header>
			<h1 id="chapter-title"><strong>CHAPTER 5: </strong>PROGRESSIVE ENHANCEMENT FOR ACCESSIBILITY</h1>
		</header>

	    <blockquote class="ch-quote">
	    	<p>“It takes many good deeds to build a good reputation, and only one bad one to lose&#160;it.”</p>
	    	<p class="author">— Benjamin Franklin</p>
	    </blockquote>

		<p>In February of 2006, the National Federation of the Blind took legal action against Target for having an inaccessible website. A month later the case went to federal court (at Target’s request). Target tried to get the case thrown out, but it didn’t fly and the case turned into a class action lawsuit that Target eventually settled in 2008 for over $6 million US (not counting attorney fees). That’s pretty substantial considering that the reason the lawsuit was filed in the first place was because Target didn’t fix accessibility issues they were alerted to: lack of <code>alt</code> text on images, heavy use of image maps, and reliance on a mouse for the submission of forms. All of these issues could have been addressed quickly and easily for far less than $6 million. Hell, I’d have done it for a few grand.</p>

		<p>If you haven’t had a lot of exposure to accessibility—with respect to this chapter, a measure of how well a site can be used by people with disabilities and the assistive technologies<a class="footnote-link" href="#footnote-222-1" id="footnote-222-1-backlink">[1]</a> they rely on—as a design consideration, it can seem incredibly daunting because there are so many factors to consider. Even if you fall into a category of users with “special needs,” it’s likely your experience and aptitudes are different from someone else with similar concerns. For example, you may have deuteranopia (a type of red-green color blindness), but yours may not be as extreme as someone else’s. You also may not be as likely to recognize potential issues for people with tritanopia (blue-yellow color blindness).</p>

		<p>If you’re the kind of person who is concerned with issues of accessibility, whether from the position of getting your message to as many people as possible or because you don’t want to make someone feel left out, the self-imposed pressure to “get it right” can seem so intense that you can’t help but approach it with trepidation.</p>

		<p>Thankfully, designing and developing with progressive enhancement improves accessibility. Progressive enhancement encourages you to build your websites in service of the content and that, more often than not, will help guide you toward the right decision when it comes to accessibility. Of course there’s always room for improvement, hence this chapter.</p>

		<h2 id="now-you-see-me">NOW YOU SEE&#160;ME…</h2>

		<p>Perhaps the most heavily-repeated pattern in JavaScript-based page manipulation is showing and hiding content. Tabbed interfaces. Collapsible elements. Accordion widgets. It crops up nearly everywhere. In and of itself, this pattern is not a bad thing, but few people realize how profoundly your choice of hiding mechanism can influence the accessibility of your content to assistive technologies like screen readers.</p>

		<p>When it comes to hiding content, there are several mechanisms for doing it and each has a different affect on the page, as summarized in the table below.</p>

		<figure id="table-5-1">
			<table>
				<thead>
					<tr>
						<th scope="col">CSS <br/>RULES</th>
						<th scope="col">DISPLAY <br/>EFFECT</th>
						<th scope="col">ACCESSIBILITY <br/>EFFECT</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td><code>visibility: hidden;</code></td>
						<td>Element is hidden from view, but is not removed from the normal flow (i.e., it still takes up the space it normally would)</td>
						<td>Content is ignored by screen readers</td>
					</tr>
					<tr>
						<td><code>display: none;</code></td>
						<td>Element is removed from the normal flow and hidden; the space it occupied is collapsed</td>
						<td>Content is ignored by screen readers</td>
					</tr>
					<tr>
						<td><code>height: 0; width: 0; overflow: hidden;</code></td>
						<td>Element is collapsed and contents are hidden</td>
						<td>Content is ignored by screen readers</td>
					</tr>
					<tr>
						<td><code>text-indent: -999em;</code></td>
						<td>Contents are shifted off-screen and hidden from view, but links may “focus” oddly and negative indent may not prove long enough to fully hide content</td>
						<td>Screen readers have access to the content, but the content is limited to text and inline elements</td>
					</tr>
					<tr>
						<td><code>position: absolute; left: -999em;</code></td>
						<td>Content is removed from the normal flow and shifted off the left-hand edge; the space it occupied is collapsed</td>
						<td>Screen readers have access to the content</td>
					</tr>
				</tbody>
			</table>
			<figcaption>
				<p><strong>Table 5.1:</strong> Mechanisms for hiding content.</p>
			</figcaption>
		</figure>


		<p>The first two mechanisms are probably the most popular, with <code>display: none;</code> being the go-to option implemented by nearly every JavaScript library on the planet and the lion’s share of ready-made JavaScript widgets. If you don’t want your hidden content to be read by a screen reader, those defaults may work for you, but if you want to ensure users have access to content (even if it isn’t displayed visually in the current interface), the final option is really the way to go.</p>

		<p>If you roll your own JavaScript library, positioning content off-screen to hide it is pretty easy to implement. If, however, you are using a third-party JavaScript library, such as jQuery or Prototype, this task becomes much more difficult to accomplish because making the change requires overwriting or otherwise changing the internals of the library. Unless, of course, you’re smart about how you do it.</p>

		<p>Most libraries include, as part of their animation suite, a mechanism for including what are referred to as “callback functions.” A callback function is a function that you supply to another function (or object method) so it can be called at a predetermined time. If you’ve used JavaScript to load content via Ajax, you’re probably familiar with the concept: callback functions are used to do something with the data you got back from the server.</p>

		<p>In most cases, JavaScript libraries only offer a callback function that runs at the completion of a given activity, but some libraries also provide hooks for various other points during the execution of a given routine, such as before the routine begins. Even without additional callback hooks, however, it’s possible to create more accessible show/hide operations. Take the following jQuery-based snippet, for example:</p>

		<pre>(function(){
  var $button = $('#myButton'),
      $text = $('#myText'),
      visible = true;
  $button.click(function(){
    if ( visible ) {
      $text.slideUp('fast');
    } else {
      $text.slideDown('fast');
    }
    visible = ! visible;
  });
})();</pre>

		<p>This script finds two elements (<code>#myButton</code> and <code>#myText</code>), assigning them to two local variables (<code>$button</code> and <code>$text</code>, respectively) before setting a third local variable (<code>visible</code>) to track the current state of things. It then goes on to assign an <code>onclick</code> event handler to <code>#myButton</code> that toggles the visibility of <code>#myText</code> by adjusting its height. Pretty straightforward, right?</p>

		<p>This script works as you’d expect, but jQuery currently uses <code>display: none</code> when you call <code>slideUp()</code>, so <code>#myText</code> is being hidden via a method that prohibits the hidden text from being read by a screen reader. By making a subtle tweak to the code, however, we can trigger the addition of a <code>class</code> we control that provides for a more accessible means of hiding content:</p>

		<pre>(function(){
  var $button = $('#myButton'),
      $text = $('#myText'),
      visible = true;
  $button.click(function(){
    if ( visible ) {
      $text.slideUp('fast',function(){
        $text
          .addClass('accessibly-hidden')
          .slideDown(0);
      });
    } else {
      $text.slideUp(0,function(){
        $text
          .removeClass('accessibly-hidden')
          .slideDown('fast');
      });
    }
    visible = ! visible;
  });
})();</pre>

		<p>This script is almost identical to the last one, in that when the content is being hidden, the library is allowed to manage the animation, but then the script swaps the default completion state for our custom <code>class</code> “accessibly-hidden,” thereby keeping the content available to assistive technologies. When the script goes to show the content, the steps are reversed, with the content being hidden by the script again before the class is removed and the actual animation is performed.</p>

		<p>The added benefit of this approach is that you control the method of hiding content completely, as opposed to leaving it up to the JavaScript library. That means you can upgrade your “accessibly-hidden” <code>class</code> to use a different technique if something better comes along and you don’t have to wait for the library to upgrade its hiding mechanism (if it ever does).</p>

		<p>Of course all of this assumes you want to hide content from being displayed, but you want to keep it available to older assistive devices. If, however, you don’t want the content to be read by a screen reader, you <span class="italic-bodycopy">could</span> use <code>display: none</code>, but it’s still not the best route to go because there’s no easy way to let the user know new content is available if you ever want to show that content. To really provide the best experience for you users, you’ll want to employ the roles and states defined in the Web Accessibility Initiative’s Accessible Rich Internet Applications spec (WAI-ARIA or ARIA, for short).<a class="footnote-link" href="#footnote-222-2" id="footnote-222-2-backlink">[2]</a></p>

		<p>Hiding content with ARIA is pretty straightforward: you simply employ the <code>aria-hidden</code> attribute.</p>

		<pre>&lt;p <strong>aria-hidden="true"</strong>&gt;<b class="text">Guess what? I’m accessibly hidden using ARIA.</b>&lt;/p&gt;</pre>

		<p>ARIA offers a number of predefined roles, states, and properties that can be of tremendous use when building a JavaScript-heavy site. There are even a handful that are useful whether you are building a highly interactive application or not. We’ll tackle those first.</p>

		<h2 id="empower-wayfinding">EMPOWER WAYFINDING</h2>

		<p>One of the many ways ARIA helps improve the accessibility of a web page is through the use of “landmark” and “structural” roles. Many of these roles formalize the significance we had been attempting to impart to elements for years via by applying semantic classifications and identifiers (as we discussed in <a href="#chapter-2">Chapter 2</a>). ARIA’s landmark and structural roles (and widget roles, which we’ll get to shortly) are assigned to an element using the <code>role</code> attribute.</p>

		<p>I know, I know: <code>role</code> isn’t a valid attribute in HTML 4.x or XHTML 1.x. It’s true. ARIA adds a host of new attributes to the HTML lexicon, which means you won’t be able to validate your pages using the same old Document Type Definitions (DTDs) you’ve been using. If you want to validate your ARIA-infused pages in either of these two languages, you’ll need to use a different set of DTDs<a class="footnote-link" href="#footnote-222-3" id="footnote-222-3-backlink">[3]</a> or make the leap to HTML5 which supports attributes like <code>role</code>.</p>

		<p>Here’s a quick example of ARIA in action:</p>

		<pre>&lt;ol <strong>role="navigation"</strong>&gt;
  &lt;li&gt;&lt;a href="#details"&gt;<b class="text">Details</b>&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="#schedule"&gt;<b class="text">Schedule</b>&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="#instructors"&gt;<b class="text">Instructors</b>&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="#lodging"&gt;<b class="text">Lodging</b>&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="#location"&gt;<b class="text">Location</b>&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</pre>

		<p>You should recognize this bit of markup from <a href="#chapter-2">Chapter 2</a>; it’s the navigation for the Retreats 4 Geeks page. The only difference between this and our original markup is that the <code>ol</code> now has a <code>role</code> attribute with a value of “navigation.” As you’d suspect, the ARIA landmark “navigation” role denotes that an element is acting as a navigational mechanism.</p>

		<p>All of ARIA’s landmark roles convey information about regions of the page itself and are useful for overall page navigation. Some assistive technologies expose these landmarks to users, allowing them to directly move from region to region via keystrokes or other means. They are the logical successor to a bevy of “skip to” links.<a class="footnote-link" href="#footnote-222-4" id="footnote-222-4-backlink">[4]</a> Structural roles, on the other hand, act as organizational tools akin to HTML5 elements like <code>section</code> and <code>article</code>.</p>

		<p>You may recall that, in the original example, we wrapped the navigational <code>ol</code> in a new HTML5 element: <code>nav</code>. If you are really on the ball, you’ll also recall that using the <code>nav</code> element is semantically-equivalent to employing the landmark role “navigation.” And this isn’t the only area of overlap between HTML5 and ARIA.</p>

		<h3 id="redundancy-and-reason">Redundancy and&#160;reason</h3>
		
		<p>These two specs developed independently over roughly the same time period and each sought to address the pressing problems they saw with the current state of HTML. (Hence, the inevitable overlap.) The ARIA spec is currently a bit closer to becoming a recommendation than HTML5 is and, as a consequence, many of its unique features are being incorporated into HTML5 as that spec continues to develop. When HTML5 finally reaches the Candidate Recommendation stage, it’s pretty safe to assume that the two specs will have been successfully merged and that redundancies will have been ironed out.</p>

		<p>For the time being, however, there is a considerable amount of overlap between ARIA and HTML5, especially in the case of structural and (to a lesser extent) landmark roles. <a href="#table-5-2">Table 5.2</a> provides a few examples of our traditional ad-hoc semantics, their equivalent ARIA role, and the HTML5 element (if any) that serves the same purpose.</p>

		<figure id="table-5-2">
			<table>
				<thead>
					<tr>
						<th scope="col">AD-HOC <br/>SEMANTICS</th>
						<th scope="col">ARIA <br/>ROLE</th>
						<th scope="col">HTML5 <br/>ELEMENT</th>
						<th scope="col">SEMANTIC <br/>MEANING</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td><code>#header, #top</code></td>
						<td>banner</td>
						<td><code>header</code> (kind of)</td>
						<td>A region of the page that is site-focused, rather than page-focused</td>
					</tr>
					<tr>
						<td><code>#main, #content</code></td>
						<td>main</td>
						<td>none</td>
						<td>The focal content in a document</td>
					</tr>
					<tr>
						<td><code>#extra, .sidebar</code></td>
						<td>complementary, note</td>
						<td><code>aside</code></td>
						<td>A supporting section of the document that is related to the main content (“complementary” content remains meaningful when separated from it)</td>
					</tr>
					<tr>
						<td><code>#footer, #bottom</code></td>
						<td>contentinfo</td>
						<td><code>footer</code></td>
						<td>A region that contains information about the document</td>
					</tr>
					<tr>
						<td><code>#nav</code></td>
						<td>navigation</td>
						<td><code>nav</code></td>
						<td>A region of the page containing navigational links</td>
					</tr>
					<tr>
						<td><code>.hentry</code></td>
						<td>article</td>
						<td><code>article</code></td>
						<td>A region of the page that forms an independent part of the document</td>
					</tr>
				</tbody>
			</table>
			<figcaption>
				<p><strong>Table 5.2:</strong> Traditional ad-hoc semantics, their equivalent ARIA role, and the HTML5 element (if any) that serves the same purpose.</p>
			</figcaption>
		</figure>
			

		<p>At present, there is a bit of back-and-forth between the HTML5 community and accessibility advocates over what to do about the redundancy. From a practical standpoint, even if you are using HTML5’s ARIA-equivalent semantics it’s generally considered a good idea to double up with the ARIA landmark roles because not all assistive technologies are HTML5-aware yet. Structural roles, however, can be assigned at your own discretion as they are purely organizational and are not currently exposed to users via assistive technology.</p>

		<p>A quick scan of the Retreats 4 Geeks source code will reveal this redundancy on the <code>nav</code> and <code>footer</code> elements. As assistive technologies are updated to be HTML5-compatible, however, we will be able to jettison the unnecessary role attributes and streamline our markup a bit more.</p>

		<p>In addition to overlap with HTML5, there are quite a few roles that duplicate the semantics long available in HTML. Consider the following ARIA landmark and structural roles: columnheader, definition, form, heading, img, list, listitem, row, rowheader, and separator. Some of those have one-to-one equivalencies in HTML (e.g., “form”) and the others are a more generalized form of what we have in HTML (e.g., “list”).</p>

		<p>While it’s understandable that the parallel development of ARIA and HTML5 would create some overlap, you may be scratching your head over why ARIA would seem to recreate semantics that have existed in HTML for over a decade. The simple answer is that, for one reason or another, some companies (<code>&lt;cough&gt;Google&lt;/cough&gt;</code>) like to use non-semantic markup (e.g., <code>div</code>s) as the basis for an interface and use JavaScript to make it function like a native HTML control. For that reason alone, ARIA provides overlapping roles. You won’t see me running out to give a <code>div</code> a role of “form” (I’ll just use a <code>form</code>, thank you), but to each his own I guess.</p>

		<p>As we discussed earlier, the Retreats 4 Geeks site implements several of the HTML5 elements that are semantically-equivalent to ARIA’s landmark and structural roles—<code>nav</code>, <code>footer</code>, <code>article</code>—but we’ve opted to include the equivalent ARIA roles in the interest of serving the greatest number of users. (After all, that’s what progressive enhancement is all about, right?) We’re not done though. As we saw in Table 5.2, the semantic equivalence of an ARIA role of “banner” to HTML5’s <code>header</code> is somewhat debatable so, to be absolutely clear in the service of our users, I’ve added that role as well:</p>

		<pre>&lt;header <strong>role="banner"</strong>&gt;</pre>

		<p>The only other role we haven’t touched on (since it’s currently not addressed in HTML5) is “main,” which indicates the focal content of the document. You may recall from <a href="#chapter-2">Chapter 2</a> that I chose a <code>section</code> element to enclose the various <code>article</code>s on the page and that it was also the element I chose to act as the root of our hCalendar; that <code>section</code> just screams “main” to me:</p>

		<pre>&lt;section id="content" class="vevent" <strong>role="main"</strong>&gt;</pre>

		<p>And with those two minor adjustments, we’ve covered every landmark role that seems sensible to employ on the Retreats 4 Geeks site. Not only that, but we’ve improved the overall accessibility of our page by providing easy ways for users of assistive technology to move around the document.</p>

		<h2 id="brother-can-you-spare-a-clue">BROTHER CAN YOU SPARE A&#160;CLUE?</h2>

		<p>In addition to providing users with a means to find their way around a document, the ARIA spec prescribes other helpful tools as well, not the least of which is its collection of widget roles and states.</p>

		<p>Widget roles do just what you’d expect them to: describe the role of a given element. These roles are generally divided into two camps: roles that provide a defined structure, and those that don’t. Or, more simply, containers and components. Containers are the elements that house the components of a given widget.</p>

		<p>Consider the tabbed interface shown in <a href="#figure-5-1">Figure 5.1</a>. A tabbed interface is constructed from two component parts: a list of tabs and a collection of panels shown by those tabs. Those parts break down into three separate roles in the ARIA spec: the tabs themselves have a <code>role</code> of “tab,” the list of tabs has a <code>role</code> of “tablist,” and each panel is assigned a role of “tabpanel.” In terms of designations, both “tab” and “tabpanel” are considered component roles, while “tablist” is considered a container role (because it contains the tabs).</p>

		<figure id="figure-5-1">
			<video controls="controls" poster="images/Ch5-1.jpg">
				<source src="videos/Ch5-1.m4v"/>
				<source src="videos/Ch5-1.webm"/>
				<source src="videos/Ch5-1.ogv"/>
				<img alt="" src="images/Ch5-1.jpg" />
			</video>
			<figcaption>
				<p><strong>Figure 5.1:</strong> A tabbed interface.</p>
			</figcaption>
		</figure>

		<p>The ARIA spec defines a number of widget roles, making it possible to construct anything from complex form controls (e.g., sliders and spinner boxes) to tree-based menus, modal dialog boxes, and drag-and-drop interfaces, all while maintaining accessibility. And, as with the structural roles we discussed earlier, ARIA even provides mechanisms for redefining nonsense markup as something functional:</p>

		<pre>&lt;div <strong>role="button"</strong>&gt;<b class="text">I&amp;#8217;m not a real button, but I play one on the web</b>&lt;/div&gt;</pre>

		<p>Of course all of this is well and good, but for any widget to work you need JavaScript and, traditionally, that’s been an accessibility no man’s land. The main reason that techniques like Ajax and accessibility didn’t mesh well was that the HTML language provided no mechanism by which JavaScript could update the user (or her assistive technology of choice) in real-time beyond <code>alert()</code> and <code>confirm()</code> (which, let’s face it, are the hooligans at the back of the user interface classroom).</p>

		<p>The ARIA spec addresses issues of context with what are called “states.” ARIA states are a set of attributes that can be applied to nearly any element. Some are global in scope (i.e., they can be applied to any element), while others are specific to certain widget contexts. All are prefaced with “aria-” and they provide valuable information to the user about what is going on with a given element.</p>

		<p>Guess what? You’re already familiar with one: <code>aria-hidden</code>. The <code>aria-hidden</code> attribute we discussed earlier in this chapter accepts a boolean (“true” or “false”) value and lets the user agent or assistive technology know whether or not the content within should be exposed to the user. Other examples of ARIA states include <code>aria-disabled</code>, <code>aria-expanded</code>, <code>aria-invalid</code>, <code>aria-pressed</code>, and <code>aria-selected</code>.</p>

		<p>In terms of the tabbed interface from <a href="#figure-5-1">Figure 5.1</a>, the states we’d likely want to employ would be <code>aria-hidden</code> for the state of the tab panels and <code>aria-selected</code> for the state of the tabs themselves.</p>

		<p>But the ARIA spec doesn’t stop there. In addition to state-indicative attributes, it also defines numerous properties that can be set on an element. Examples include <code>aria-autocomplete</code>, <code>aria-controls</code>, <code>aria-label</code>, <code>aria-labelledby</code>, <code>aria-readonly</code>, and <code>aria-required</code>. As you can see, most of the properties are meant for use with form controls, but a few (like <code>aria-controls</code>) can apply to our tabbed interface.</p>

		<p>As you probably suspect, the <code>aria-controls</code> takes an <code>id</code> reference for a value and that <code>id</code> should belong to the element whose contents or presence is controlled by the element to which the attribute is applied. In the case of the tabbed interface, the tab would “control” its associated tab panel (as shown in <a href="#figure-5-2">Figure 5.2</a>). With the tab-to-tab-panel relationship established, it seems only fair to establish the relationship in the other direction as well; that’s where <code>aria-labelledby</code> can be put to use. It works in precisely the same way as <code>aria-controls</code>.</p>

		<figure id="figure-5-2">
			<img alt="" src="images/Ch5-2.jpg" />
			<figcaption>
				<p><strong>Figure 5.2:</strong> Using ARIA properties, we can relate pieces of an interface to one another.</p>
			</figcaption>
		</figure>

		<p>ARIA’s states and properties go a long way toward helping keep the user informed, but few concepts in ARIA are as simple and immediately useful as Live Regions.</p>

		<h2 id="its-alive">IT’S ALIVE!</h2>

		<p>With the advent of Ajax and the resurgence of JavaScript in general, few things proved to be more of a user experience nightmare than live-updating regions of the page. The usability issues were numerous, but the two big ones were: 1) assistive devices weren’t aware of changes to the page and had no way of directing a user’s attention to them; and 2) users taking advantage of page zoom or browsing on a mobile device are oblivious to content updates occurring off-screen. Thankfully, the ARIA spec includes an attribute that directly addresses this egregious problem: <code>aria-live</code>.</p>

		<p>What’s most exciting about <code>aria-live</code> is its simplicity. By applying this single attribute to an element, you can control how and when content updates within it are presented to your users. The <code>aria-live</code> attribute accepts one of three values:</p>

		<ol>
		  <li>“off” for when updates are frequent and of little importance to the user, as in the case of a live stream from your Twitter account (doh!);</li>
		  <li>“polite” for when updates are only important enough to be announced when the user isn’t doing anything, as in the case of updated news headlines; or</li>
		  <li>“assertive” for when updates are important enough to announce immediately, as in the case of form validation messages.</li>
		</ol>

		<p>In the Retreats 4 Geeks website, it makes sense to apply <code>aria-live</code> to the contact form:</p>

		<pre>&lt;article id="contact" <strong>aria-live="assertive"</strong>&gt;</pre>

		<p>With that in place, users will be kept abreast of any errors encountered when filling in their details and will also be informed when the submission is successful.</p>

		<h2 id="support-and-stumbling-blocks">SUPPORT AND STUMBLING&#160;BLOCKS</h2>

		<p>Since its introduction, ARIA has gotten a lot of support from the web community. As of this writing, some level of ARIA support is found in every major browser and has been implemented in popular screen reading tools like JAWS, Windows Eyes, NVDA, and Orca. Influential companies like IBM, Sun Microsystems, Adobe, Yahoo!, and Google are all working diligently to increase ARIA’s effectiveness and reach. Even the Javascript community has embraced ARIA, with both Dojo Dijits<a class="footnote-link" href="#footnote-222-5" id="footnote-222-5-backlink">[5]</a> and jQuery UI<a class="footnote-link" href="#footnote-222-6" id="footnote-222-6-backlink">[6]</a> integrating ARIA’s roles, states, and properties into their components. Of course, the spec is still developing, so no implementation is complete, but progress is being made.</p>

		<p>I’d be remiss if I did not mention the one major issue keeping ARIA from fitting neatly into the progressive enhancement stack, at least when it comes to widget-related roles and states: we have no way of testing for ARIA support in the browser or assistive technology and, therefore, can’t make informed decisions about how to best implement a given widget. Derek Featherstone surfaced this issue in his excellent article for <span class="italic-bodycopy italic-bodycopy-override-2">A List Apart</span> Entitled “ARIA and Progressive Enhancement.”<a class="footnote-link" href="#footnote-222-7" id="footnote-222-7-backlink">[7]</a> I highly recommend reading it to better understand the issue. At the time of this writing, a viable solution has not been proposed, but my fingers are crossed.</p>
	
		<h2 id="keystroke-isnt-a-dirty-word">KEYSTROKE ISN’T A DIRTY&#160;WORD</h2>

		<p>The last topic I want to touch on before we wrap this, the
		final chapter of my little book, is keyboard access and controls. With the pervasiveness of the mouse and an increased reliance on touch-based devices like the iPad, it is relatively easy to forget about the humble keyboard, but that would be a critical mistake. The keyboard is an incredibly useful tool and is the standard interface for all non-visual users and most power-users.</p>

		<p>When it comes to the keyboard, we’ve learned a great deal in the last few years. First off, we realized that access keys were a good idea in theory, but not so great in practice.<a class="footnote-link" href="#footnote-222-8" id="footnote-222-8-backlink">[8]</a> Second, we realized that overzealous application of the <code>tabindex</code> attribute could get your users jumping (and not in a good way).<a class="footnote-link" href="#footnote-222-9" id="footnote-222-9-backlink">[9]</a> But the most important thing we discovered is that we could use JavaScript to “juggle” the <code>tabindex</code> attribute to streamline a user’s path through a complex widget like a tabbed interface or an accordion form.</p>

		<p>So what exactly is <code>tabindex</code> juggling? Well, some time in 2005 (it’s hard to pin down the exact origin) it was discovered that assigning a value of “-1” to the <code>tabindex</code> attribute of an element would remove that element from the default tab order of the document.<a class="footnote-link" href="#footnote-222-10" id="footnote-222-10-backlink">[10]</a> Interestingly, despite being taken out of the document’s tab order, the element remained focusable via JavaScript (<code>element.focus()</code>), which opened up a lot of possibilities for controlling a user’s experience.</p>

		<p>Let’s walk through a scenario, revisiting the tabbed interface from earlier:</p>

		<ol>
		  <li>A user arrives at the tabbed interface and clicks the <kbd>tab</kbd> key on her keyboard, bringing focus to the first tab (which is associated with the visible tab panel).</li>
		  <li>Clicking the <kbd>tab</kbd> button again moves focus out of the tab interface to the next piece of focusable content instead of taking her to the next tab in the list.</li>
		  <li>Holding <kbd>shift</kbd> while hitting the <kbd>tab</kbd> key brings the user back into the tab list and restores focus to the currently active tab.</li>
		  <li>Using the arrow keys, she can move forward and backward through the tabs in the tab list, bringing each associated tab panel into view as she moves.</li>
		  <li>Hitting the <kbd>enter</kbd> button at any point while navigating through the tab list brings focus to the tab panel associated with that tab.</li>
		</ol>

		<p>I know that’s a lot of “tabs” (and a bit of a tall order), but with <code>tabindex</code> juggling and a little JavaScript it becomes quite simple to achieve. Here’s how:</p>

		<ol>
		  <li>By assigning a <code>tabindex</code> of “-1” to every tab and tab panel, you can remove them from the tab order of the page.</li>
		  <li>Going back and re-assigning a value of “0” to the currently active tab restores their default position in the tab order.</li>
		  <li>Using JavaScript you can dynamically adjust the <code>tabindex</code> property of each tab as a user executes keyboard commands like left or right, up or down, allowing the user to move quickly and easily through the interface.</li>
		</ol>

		<p>Here’s a snippet from <code>TabInterface</code>’s <code>swap</code> method that shows <code>tabindex</code> juggling in action (along with some ARIA attribute manipulation and <code>class</code> swapping):</p>

		<pre>function swap( e )
{
  <b class="comment">// …
  /* De-activating the current tab &amp; tab panel */</b>
  removeClassName( old_tab, 'active' );
  old_tab.setAttribute( 'aria-selected', 'false' );
  old_tab.setAttribute( 'tabindex', '-1' );
  removeClassName( old_folder, 'visible' );
  old_folder.setAttribute( 'aria-hidden', 'true' );
  <b class="comment">/* Activating the new tab &amp; tab panel */</b>
  addClassName( tab, 'active' );
  tab.setAttribute( 'aria-selected', 'true' );
  tab.setAttribute( 'tabindex', '0' );
  addClassName( new_folder, 'visible' );
  new_folder.setAttribute( 'aria-hidden', 'false' );
  <b class="comment">// …</b>
}</pre>

		<p>If you’d like to see this technique in action, you can check out TabInterface.js on Github.<a class="footnote-link" href="#footnote-222-11" id="footnote-222-11-backlink">[11]</a></p>

		<h2 id="just-do-it-accessibly">JUST DO IT… ACCESSIBLY</h2>

		<p>Accessibility is complex and can be difficult to wrap your mind around, but if you tackle it a little at a time, it becomes second nature. And, as with everything else in this book, accessibility is most easily applied in layers, building up the interface bit by bit to create something that meets your users’ needs, whatever they may be.</p>

		<footer>
			<ol id="footnotes">
				<li><a class="backlink" href="#footnote-222-1-backlink" id="footnote-222-1">[1]</a> Assistive technologies come in many forms. Blind people who use screen-reading software. People with partially impaired vision may enlarge text in the browser. The deaf often rely on captioning to easily follow videos.</li>
				<li><a class="backlink" href="#footnote-222-2-backlink" id="footnote-222-2">[2]</a> <a class="url" href="http://www.w3.org/TR/wai-aria/">w3.org/TR/wai-aria/</a></li>
				<li><a class="backlink" href="#footnote-222-3-backlink" id="footnote-222-3">[3]</a> The HTML 4.01 plus WAI-ARIA <code>DOCTYPE</code> is <code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML+ARIA 1.0//EN" "http://www.w3.org/WAI/ARIA/schemata/html4-aria-1.dtd"&gt;</code>. The XHTML plus WAI-ARIA <code>DOCTYPE</code> is <code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+ARIA 1.0//EN" "http://www.w3.org/WAI/ARIA/schemata/xhtml-aria-1.dtd"&gt;</code>.</li>
				<li><a class="backlink" href="#footnote-222-4-backlink" id="footnote-222-4">[4]</a> “Skip to” links are links that provide anchor-based access to regions of a page. Common implementations include “Skip to content” and “Skip to navigation.” They were a mainstay of the web standards world for many years, but ARIA’s landmark roles make these links redundant.</li>
				<li><a class="backlink" href="#footnote-222-5-backlink" id="footnote-222-5">[5]</a> <a class="url" href="http://dojotoolkit.org/widgets">dojotoolkit.org/widgets</a></li>
				<li><a class="backlink" href="#footnote-222-6-backlink" id="footnote-222-6">[6]</a> <a class="url" href="http://jqueryui.com/">jQueryUI.com</a></li>
				<li><a class="backlink" href="#footnote-222-7-backlink" id="footnote-222-7">[7]</a> <a class="url" href="http://alistapart.com/articles/aria-and-progressive-enhancement/">alistapart.com/articles/aria-and-progressive-enhancement/</a></li>
				<li><a class="backlink" href="#footnote-222-8-backlink" id="footnote-222-8">[8]</a> <a class="url" href="http://www.wats.ca/show.php?contentid=32">wats.ca/show.php?contentid=32</a></li>
				<li><a class="backlink" href="#footnote-222-9-backlink" id="footnote-222-9">[9]</a> <a class="url" href="http://webaim.org/techniques/keyboard/tabindex">webaim.org/techniques/keyboard/tabindex</a></li>
				<li><a class="backlink" href="#footnote-222-10-backlink" id="footnote-222-10">[10]</a> This was especially interesting because, according to the W3C spec, <code>tabindex</code> should only accept values between 0 and 32767.</li>
				<li><a class="backlink" href="#footnote-222-11-backlink" id="footnote-222-11">[11]</a> <a class="url" href="http://github.com/easy-designs/TabInterface.js">github.com/easy-designs/TabInterface.js</a></li>
			</ol>
		</footer>
	</div>
	
	<nav class="navigation">
		<h1>TABLE OF CONTENTS</h1>
		<ol>
			<li><a href="index.html">Front Matter</a></li>
			<li><a href="foreword.html">Foreword</a></li>
			<li><a href="chapter-1.html">Chapter 1: Think of the User, Not the Browser</a></li>
			<li><a href="chapter-2.html">Chapter 2: Progressive Enhancement with Markup</a></li>
			<li><a href="chapter-3.html">Chapter 3: Progressive Enhancement with CSS</a></li>
			<li><a href="chapter-4.html">Chapter 4: Progressive Enhancement with JavaScript</a></li>
			<li><a href="chapter-5.html"><mark>Chapter 5: Progressive Enhancement for Accessibility</mark></a></li>
			<li><a href="chapter-6.html">Chapter 6: Take It Away</a></li>
			<li><a href="back.html">Back Matter</a></li>
		<ol>
	</nav>
	
	<footer class="contentinfo">
		<p>Copyright © 2011 Aaron Gustafson. All rights reserved. ISBN: 978-0-9835895-1-8</p>
	</footer>
	
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-58149754-1', 'auto');
	  ga('send', 'pageview');

	</script>
</body>
</html>
